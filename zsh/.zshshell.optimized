# ============================================================================
# 自定義 Shell 函數集合 - 基於 fzf 的增強工具
# 版本: 2.0 (優化版)
# ============================================================================

# ============================================================================
# TMUX 管理工具
# ============================================================================

# ftm - 創建新 tmux session 或切換到現有 session
# 用法: ftm [session_name]
# 如果提供 session_name，直接切換或創建；否則使用 fzf 選擇
ftm() {
    # 檢查 tmux 是否安裝
    if ! command -v tmux >/dev/null 2>&1; then
        echo "錯誤: tmux 未安裝" >&2
        return 1
    fi

    local change_cmd
    [[ -n "$TMUX" ]] && change_cmd="switch-client" || change_cmd="attach-session"
    
    # 如果提供了參數，直接處理
    if [[ $# -gt 0 ]]; then
        local session_name="$1"
        if tmux has-session -t "$session_name" 2>/dev/null; then
            tmux $change_cmd -t "$session_name"
        else
            echo "創建新 session: $session_name"
            tmux new-session -d -s "$session_name" && tmux $change_cmd -t "$session_name"
        fi
        return
    fi
    
    # 使用 fzf 選擇 session
    local sessions
    sessions=$(tmux list-sessions -F "#{session_name}: #{session_windows} windows (#{session_attached} attached)" 2>/dev/null)
    
    if [[ -z "$sessions" ]]; then
        echo "沒有現有的 tmux session，創建新的 session..."
        read -p "輸入新 session 名稱 (預設: main): " session_name
        session_name=${session_name:-main}
        tmux new-session -d -s "$session_name" && tmux $change_cmd -t "$session_name"
        return
    fi
    
    local selected_session
    selected_session=$(echo "$sessions" | fzf \
        --height=40% \
        --border \
        --prompt="選擇 tmux session: " \
        --preview="tmux list-windows -t {1} -F '#{window_index}: #{window_name} #{window_active}'" \
        --preview-window=right:50% \
        | cut -d: -f1)
    
    if [[ -n "$selected_session" ]]; then
        tmux $change_cmd -t "$selected_session"
    else
        echo "未選擇任何 session"
    fi
}

# fs - 快速切換 tmux session (簡化版)
# 用法: fs [FUZZY_PATTERN]
fs() {
    if ! command -v tmux >/dev/null 2>&1; then
        echo "錯誤: tmux 未安裝" >&2
        return 1
    fi

    local session
    session=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | \
        fzf --query="$1" --select-1 --exit-0 --height=40% --border)
    
    if [[ -n "$session" ]]; then
        tmux switch-client -t "$session"
    else
        echo "未找到匹配的 session"
    fi
}

# ============================================================================
# 檔案搜尋與編輯工具
# ============================================================================

# vg - 使用 ripgrep 搜尋並用編輯器開啟檔案
# 用法: vg [搜尋模式] [其他 rg 參數]
vg() {
    if [[ $# -eq 0 ]]; then
        echo "用法: vg <搜尋模式> [其他 rg 參數]"
        echo "範例: vg 'function' --type js"
        return 1
    fi

    if ! command -v rg >/dev/null 2>&1; then
        echo "錯誤: ripgrep (rg) 未安裝" >&2
        return 1
    fi

    local file line
    local result=$(rg --color=always --line-number --no-heading --smart-case "$@" | \
        fzf --ansi \
            --height=60% \
            --border \
            --prompt="選擇檔案: " \
            --delimiter=: \
            --preview="bat --color=always --highlight-line {2} {1}" \
            --preview-window=right:60%:+{2}+3/2 \
            --bind="enter:become(echo {1}:{2})")
    
    if [[ -n "$result" ]]; then
        file=$(echo "$result" | cut -d: -f1)
        line=$(echo "$result" | cut -d: -f2)
        
        # 根據編輯器類型開啟檔案並跳到指定行
        case "${EDITOR:-nvim}" in
            nvim|vim)
                ${EDITOR:-nvim} "+$line" "$file"
                ;;
            code)
                code --goto "$file:$line"
                ;;
            *)
                ${EDITOR:-nvim} "$file"
                ;;
        esac
    fi
}

# ff - 使用 fd 搜尋檔案並開啟
# 用法: ff [搜尋模式]
ff() {
    if ! command -v fd >/dev/null 2>&1; then
        echo "錯誤: fd 未安裝" >&2
        return 1
    fi

    local file
    file=$(fd --type f --hidden --follow --exclude .git . | \
        fzf --query="$1" \
            --height=60% \
            --border \
            --prompt="選擇檔案: " \
            --preview="bat --color=always --style=numbers {}" \
            --preview-window=right:60%)
    
    if [[ -n "$file" ]]; then
        ${EDITOR:-nvim} "$file"
    fi
}

# fcd - 使用 fd 搜尋目錄並切換
# 用法: fcd [搜尋模式]
fcd() {
    if ! command -v fd >/dev/null 2>&1; then
        echo "錯誤: fd 未安裝" >&2
        return 1
    fi

    local dir
    dir=$(fd --type d --hidden --follow --exclude .git . | \
        fzf --query="$1" \
            --height=40% \
            --border \
            --prompt="選擇目錄: " \
            --preview="eza --tree --level=2 --color=always {}" \
            --preview-window=right:50%)
    
    if [[ -n "$dir" ]]; then
        cd "$dir" && echo "已切換到: $(pwd)"
    fi
}

# ============================================================================
# 程序管理工具
# ============================================================================

# fkill - 使用 fzf 選擇並終止程序
# 用法: fkill [信號編號，預設為 9]
fkill() {
    local signal=${1:-9}
    
    # 獲取程序列表，排除標題行
    local processes
    processes=$(ps -eo pid,ppid,user,%cpu,%mem,command --sort=-%cpu | sed 1d)
    
    if [[ -z "$processes" ]]; then
        echo "未找到任何程序"
        return 1
    fi
    
    local selected_pids
    selected_pids=$(echo "$processes" | \
        fzf --multi \
            --height=60% \
            --border \
            --prompt="選擇要終止的程序 (可多選): " \
            --header="PID    PPID   USER     %CPU  %MEM  COMMAND" \
            --preview="echo {}" \
            --preview-window=up:3 \
            | awk '{print $1}')
    
    if [[ -n "$selected_pids" ]]; then
        echo "將要終止的程序 PID: $selected_pids"
        read -p "確認終止這些程序嗎? (y/N): " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            echo "$selected_pids" | xargs kill -"$signal"
            echo "已發送信號 $signal 到選定的程序"
        else
            echo "已取消操作"
        fi
    else
        echo "未選擇任何程序"
    fi
}

# ============================================================================
# Docker 管理工具
# ============================================================================

# fdim - 使用 fzf 選擇並刪除 Docker 映像
# 用法: fdim
fdim() {
    if ! command -v docker >/dev/null 2>&1; then
        echo "錯誤: Docker 未安裝" >&2
        return 1
    fi

    local images
    images=$(docker image ls --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.Size}}\t{{.CreatedAt}}")
    
    if [[ $(echo "$images" | wc -l) -le 1 ]]; then
        echo "沒有找到 Docker 映像"
        return 1
    fi
    
    local selected_images
    selected_images=$(echo "$images" | sed 1d | \
        fzf --multi \
            --height=60% \
            --border \
            --prompt="選擇要刪除的映像 (可多選): " \
            --header="REPOSITORY    TAG    IMAGE ID    SIZE    CREATED" \
            --preview="docker image inspect {3} --format='{{json .}}' | jq -r '.Config.Env[]?' 2>/dev/null || echo 'No environment info'" \
            --preview-window=right:40% \
            | awk '{print $3}')
    
    if [[ -n "$selected_images" ]]; then
        echo "將要刪除的映像 ID:"
        echo "$selected_images"
        read -p "確認刪除這些映像嗎? (y/N): " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            echo "$selected_images" | xargs docker image rm -f
            echo "映像刪除完成"
        else
            echo "已取消操作"
        fi
    else
        echo "未選擇任何映像"
    fi
}

# fdc - 使用 fzf 選擇並管理 Docker 容器
# 用法: fdc [action] (action: start, stop, restart, remove, logs, exec)
fdc() {
    if ! command -v docker >/dev/null 2>&1; then
        echo "錯誤: Docker 未安裝" >&2
        return 1
    fi

    local action=${1:-"select"}
    local containers
    containers=$(docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Image}}\t{{.Ports}}")
    
    if [[ $(echo "$containers" | wc -l) -le 1 ]]; then
        echo "沒有找到 Docker 容器"
        return 1
    fi
    
    local selected_container
    selected_container=$(echo "$containers" | sed 1d | \
        fzf --height=60% \
            --border \
            --prompt="選擇容器: " \
            --header="NAME    STATUS    IMAGE    PORTS" \
            --preview="docker inspect {1} --format='{{json .State}}' | jq -r ." \
            --preview-window=right:40% \
            | awk '{print $1}')
    
    if [[ -n "$selected_container" ]]; then
        case "$action" in
            "start") docker start "$selected_container" ;;
            "stop") docker stop "$selected_container" ;;
            "restart") docker restart "$selected_container" ;;
            "remove") docker rm -f "$selected_container" ;;
            "logs") docker logs -f "$selected_container" ;;
            "exec") docker exec -it "$selected_container" /bin/bash ;;
            *) echo "容器: $selected_container" ;;
        esac
    else
        echo "未選擇任何容器"
    fi
}

# ============================================================================
# 網路工具
# ============================================================================

# myip - 顯示本機和公網 IP 地址
myip() {
    echo "正在獲取 IP 地址資訊..."
    
    # 本機 IP (支援多種網卡)
    local local_ips
    local_ips=$(ifconfig | grep -E "inet [0-9]" | grep -v "127.0.0.1" | awk '{print $2}')
    
    # 公網 IP (使用多個服務作為備選)
    local public_ip
    for service in "https://api.ipify.org" "https://ifconfig.me" "https://icanhazip.com"; do
        public_ip=$(curl -s --max-time 5 "$service" 2>/dev/null)
        if [[ -n "$public_ip" ]]; then
            break
        fi
    done
    
    # 顯示結果
    echo ""
    echo "🌐 IP 地址資訊:"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    if [[ -n "$local_ips" ]]; then
        echo "🏠 本機 IP:"
        while IFS= read -r ip; do
            echo "   $ip"
        done <<< "$local_ips"
    else
        echo "🏠 本機 IP: 未找到"
    fi
    
    echo ""
    if [[ -n "$public_ip" ]]; then
        echo "🌍 公網 IP: $public_ip"
        
        # 獲取地理位置資訊 (可選)
        if command -v curl >/dev/null 2>&1; then
            local geo_info
            geo_info=$(curl -s "http://ip-api.com/json/$public_ip" 2>/dev/null | \
                jq -r '"\(.country) \(.regionName) \(.city)"' 2>/dev/null)
            if [[ -n "$geo_info" && "$geo_info" != "null null null" ]]; then
                echo "📍 位置: $geo_info"
            fi
        fi
    else
        echo "🌍 公網 IP: 無法獲取 (請檢查網路連接)"
    fi
    
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

# ============================================================================
# Git 工具
# ============================================================================

# fgb - 使用 fzf 選擇並切換 Git 分支
fgb() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "錯誤: 不在 Git 倉庫中" >&2
        return 1
    fi

    local branch
    branch=$(git branch -a --color=always | \
        grep -v '/HEAD\s' | \
        sort | \
        fzf --ansi \
            --height=40% \
            --border \
            --prompt="選擇分支: " \
            --preview="git log --oneline --graph --date=short --pretty='format:%C(auto)%cd %h%d %s' {1} | head -10" \
            --preview-window=right:50% \
            | sed 's/^..//' | sed 's#remotes/[^/]*/##')
    
    if [[ -n "$branch" ]]; then
        git checkout "$branch"
    fi
}

# fgl - 使用 fzf 瀏覽 Git 日誌
fgl() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "錯誤: 不在 Git 倉庫中" >&2
        return 1
    fi

    git log --graph --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" | \
        fzf --ansi --no-sort --reverse --tiebreak=index \
            --height=60% \
            --border \
            --prompt="Git 日誌: " \
            --preview="echo {} | grep -o '[a-f0-9]\{7\}' | head -1 | xargs -I % sh -c 'git show --color=always %'" \
            --preview-window=right:60% \
            --bind="enter:execute(echo {} | grep -o '[a-f0-9]\{7\}' | head -1 | xargs -I % sh -c 'git show %')"
}

# ============================================================================
# 系統資訊工具
# ============================================================================

# sysinfo - 顯示系統資訊摘要
sysinfo() {
    echo "🖥️  系統資訊摘要"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "💻 系統: $(uname -s) $(uname -r)"
    echo "🏗️  架構: $(uname -m)"
    echo "🧠 CPU: $(sysctl -n machdep.cpu.brand_string 2>/dev/null || echo "未知")"
    echo "💾 記憶體: $(echo "scale=2; $(sysctl -n hw.memsize 2>/dev/null || echo 0) / 1024 / 1024 / 1024" | bc 2>/dev/null || echo "未知") GB"
    echo "⏰ 運行時間: $(uptime | awk -F'up ' '{print $2}' | awk -F', load' '{print $1}')"
    echo "🌡️  負載: $(uptime | awk -F'load averages: ' '{print $2}')"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

# ============================================================================
# 幫助函數
# ============================================================================

# fzf_help - 顯示所有自定義 fzf 函數的幫助
fzf_help() {
    cat << 'EOF'
🔍 FZF 增強工具集合

📁 檔案與目錄:
  ff [pattern]     - 搜尋並開啟檔案
  fcd [pattern]    - 搜尋並切換目錄
  vg <pattern>     - 搜尋文字內容並開啟檔案

🖥️  TMUX 管理:
  ftm [session]    - 創建或切換 tmux session
  fs [pattern]     - 快速切換 tmux session

🔧 程序管理:
  fkill [signal]   - 選擇並終止程序

🐳 Docker 工具:
  fdim             - 選擇並刪除 Docker 映像
  fdc [action]     - 管理 Docker 容器

🌐 Git 工具:
  fgb              - 選擇並切換 Git 分支
  fgl              - 瀏覽 Git 日誌

🌍 網路工具:
  myip             - 顯示 IP 地址資訊

ℹ️  系統資訊:
  sysinfo          - 顯示系統資訊摘要
  fzf_help         - 顯示此幫助資訊

💡 提示: 大部分函數支援多選 (使用 Tab 鍵) 和預覽功能
EOF
}
